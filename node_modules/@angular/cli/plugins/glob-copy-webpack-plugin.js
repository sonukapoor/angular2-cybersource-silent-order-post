"use strict";
const fs = require('fs');
const path = require('path');
const glob = require('glob');
const denodeify = require('denodeify');
const globPromise = denodeify(glob);
const statPromise = denodeify(fs.stat);
function isDirectory(path) {
    try {
        return fs.statSync(path).isDirectory();
    }
    catch (_) {
        return false;
    }
}
class GlobCopyWebpackPlugin {
    constructor(options) {
        this.options = options;
    }
    apply(compiler) {
        let { patterns, globOptions } = this.options;
        let context = globOptions.cwd || compiler.options.context;
        let optional = !!globOptions.optional;
        // convert dir patterns to globs
        patterns = patterns.map(pattern => isDirectory(path.resolve(context, pattern))
            ? pattern += '/**/*'
            : pattern);
        // force nodir option, since we can't add dirs to assets
        globOptions.nodir = true;
        compiler.plugin('emit', (compilation, cb) => {
            let globs = patterns.map(pattern => globPromise(pattern, globOptions));
            let addAsset = (relPath) => compilation.assets[relPath]
                ? Promise.resolve()
                : statPromise(path.resolve(context, relPath))
                    .then((stat) => compilation.assets[relPath] = {
                    size: () => stat.size,
                    source: () => fs.readFileSync(path.resolve(context, relPath))
                })
                    .catch((err) => optional ? Promise.resolve() : Promise.reject(err));
            Promise.all(globs)
                .then(globResults => [].concat.apply([], globResults))
                .then((relPaths) => Promise.all(relPaths.map((relPath) => addAsset(relPath))))
                .catch((err) => compilation.errors.push(err))
                .then(() => cb());
        });
    }
}
exports.GlobCopyWebpackPlugin = GlobCopyWebpackPlugin;
//# sourceMappingURL=/Users/hansl/Sources/angular-cli/packages/@angular/cli/plugins/glob-copy-webpack-plugin.js.map