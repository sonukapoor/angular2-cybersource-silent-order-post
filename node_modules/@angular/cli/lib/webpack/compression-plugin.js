"use strict";
/** Forked from https://github.com/webpack/compression-webpack-plugin. */
const async = require('async');
const url = require('url');
const RawSource = require('webpack-sources/lib/RawSource');
class CompressionPlugin {
    constructor(options = {}) {
        this.asset = '[path].gz[query]';
        this.compressionOptions = {};
        this.threshold = 0;
        this.minRatio = 0.8;
        if (options.hasOwnProperty('asset')) {
            this.asset = options.asset;
        }
        const algorithm = options.hasOwnProperty('algorithm') ? options.algorithm : 'gzip';
        const zlib = require('zlib');
        this.compressionOptions = {};
        this.algorithm = zlib[algorithm];
        if (!this.algorithm) {
            throw new Error(`Algorithm not found in zlib: "${algorithm}".`);
        }
        this.compressionOptions = {
            level: options.level || 9,
            flush: options.flush,
            chunkSize: options.chunkSize,
            windowBits: options.windowBits,
            memLevel: options.memLevel,
            strategy: options.strategy,
            dictionary: options.dictionary
        };
        if (options.hasOwnProperty('test')) {
            if (Array.isArray(options.test)) {
                this.test = options.test;
            }
            else {
                this.test = [options.test];
            }
        }
        if (options.hasOwnProperty('threshold')) {
            this.threshold = options.threshold;
        }
        if (options.hasOwnProperty('minRatio')) {
            this.minRatio = options.minRatio;
        }
    }
    apply(compiler) {
        compiler.plugin('this-compilation', (compilation) => {
            compilation.plugin('optimize-assets', (assets, callback) => {
                async.forEach(Object.keys(assets), (file, callback) => {
                    if (this.test.every((t) => !t.test(file))) {
                        return callback();
                    }
                    const asset = assets[file];
                    let content = asset.source();
                    if (!Buffer.isBuffer(content)) {
                        content = new Buffer(content, 'utf-8');
                    }
                    const originalSize = content.length;
                    if (originalSize < this.threshold) {
                        return callback();
                    }
                    this.algorithm(content, this.compressionOptions, (err, result) => {
                        if (err) {
                            return callback(err);
                        }
                        if (result.length / originalSize > this.minRatio) {
                            return callback();
                        }
                        const parse = url.parse(file);
                        const newFile = this.asset
                            .replace(/\[file]/g, file)
                            .replace(/\[path]/g, parse.pathname)
                            .replace(/\[query]/g, parse.query || '');
                        assets[newFile] = new RawSource(result);
                        callback();
                    });
                }, callback);
            });
        });
    }
}
exports.CompressionPlugin = CompressionPlugin;
//# sourceMappingURL=/Users/hansl/Sources/angular-cli/packages/@angular/cli/lib/webpack/compression-plugin.js.map